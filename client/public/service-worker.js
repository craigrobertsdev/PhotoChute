/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { precacheAndRoute } from "workbox-precaching";
import { clientsClaim } from "workbox-core";

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

const version = 2;
let imageName = `imageCache-${version}`;

self.addEventListener("install", (event) => {
  // service worker has been installed.

  console.log(`Version ${version} installed`);
});

self.addEventListener("activate", (event) => {
  // when the service worker has been activated to replace an old one.
  //Extendable Event
  console.log("activated");
  // delete old versions of caches.
  event.waitUntil(
    caches.keys().then((keys) => {
      return Promise.all(
        keys
          .filter((key) => {
            if (key != imageName) {
              return true;
            }
          })
          .map((key) => caches.delete(key))
      ).then((empties) => {
        //empties is an Array of boolean values.
        //one for each cache deleted
      });
    })
  );
});

self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

// Any other custom service worker logic can go here.
self.addEventListener("fetch", async (event) => {
  console.log(`fetch request for: ${event.request.url}`);
  if (event.request.url.startsWith("https://photochute")) {
    const requestUrl = event.request.url.slice(0, event.request.url.lastIndexOf("?"));

    event.respondWith(
      caches
        .match(requestUrl, {
          ignoreSearch: true,
          ignoreMethod: true,
          ignoreVary: true,
        })
        .then((cacheRes) => {
          // console.log(cacheRes);
          console.log(event.request);
          return (
            cacheRes ||
            fetch(event.request).then((fetchResponse) => {
              return caches.open("images").then((cache) => {
                const clone = fetchResponse.clone();
                const clone2 = fetchResponse.clone();
                clone.blob().then((value) => {
                  console.log(value.type);
                  if (value.type.startsWith("image")) {
                    cache.put(event.request, clone2.clone());
                  }
                });

                return fetchResponse;
              });
            })
          );
        })
    );
  }

  if (event.request.url.endsWith("graphql")) {
    console.log(event.request);
  }
});

// self.addEventListener("fetch", (event) => {
//   if (event.request.url.startsWith("https://photochute")) {
//     console.log(event.request.url);
//     const requestUrl = event.request.url.slice(0, event.request.url.lastIndexOf("?"));
//     const cachedResponsePromise = caches.match(requestUrl, {
//       ignoreSearch: true,
//       ignoreMethod: true,
//       ignoreVary: true,
//     });

//     const imageCachePromise = caches.open("images").then((imageCache) => {
//       console.log(imageCache);
//       return imageCache.match(event.request.url);
//     });

//     // imageCachePromise.then((imageCacheResponse) => {
//     //   return imageCache.keys().then((keys) => {
//     //     for (const image of keys) {
//     //       console.log(event.request.url, image.url, event.request.url === image.url);
//     //     }
//     //   });
//     // });

//     // console.log(cachedResponse);
//     const responsePromise = cachedResponsePromise.then((cachedResponse) => {
//       if (cachedResponse) {
//         console.log("responding with cachedResponse", cachedResponse);
//         event.respondWith(cachedResponse);
//       } else {
//         return fetch(event.request.url).then((response) => {
//           return caches.open("images").then((cache) => {
//             cache.put(event.request, response.clone());
//             return response;
//           });
//         });
//       }
//     });

//     event.waitUntil(responsePromise);
//   }
// });
